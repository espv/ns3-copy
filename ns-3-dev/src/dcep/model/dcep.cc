/*
 * Copyright (C) 2018, Fabrice S. Bigirimana
 * Copyright (c) 2018, University of Oslo
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * 
 */

#include "dcep.h"
#include "ns3/node.h"
#include "ns3/uinteger.h"
#include "ns3/object.h"
#include "ns3/log.h"
#include "ns3/random-variable-stream.h"
#include "placement.h"
#include "communication.h"
#include "cep-engine.h"
#include "common.h"
#include "ns3/simulator.h"
#include "ns3/config.h"
#include "ns3/string.h"
#include "ns3/boolean.h"
#include "ns3/processing-module.h"
#include "ns3/object-base.h"
#include "dcep-state.h"

#include <ctime>
#include <chrono>
#include <iostream>
#include <fstream>
#include <random>

namespace ns3 {

NS_OBJECT_ENSURE_REGISTERED(Dcep);
NS_LOG_COMPONENT_DEFINE ("Dcep");


    TypeId
    Dcep::GetTypeId(void)
    {
        static TypeId tid = TypeId("ns3::Dcep")
        .SetParent<Application> ()
        .SetGroupName("Applications")
        .AddConstructor<Dcep> ()
        .AddAttribute ("placement_policy", "The placement mechanism policy being used",
                       StringValue("centralized"),
                       MakeStringAccessor (&Dcep::placementPolicy),
                       MakeStringChecker())
        .AddAttribute ("IsGenerator",
                       "This attribute is used to configure the current node as a datasource",
                       BooleanValue (false),
                       MakeBooleanAccessor (&Dcep::datasource_node),
                       MakeBooleanChecker ())
        .AddAttribute ("IsSink",
                       "This attribute is used to configure the current node as a Sink",
                       BooleanValue (false),
                       MakeBooleanAccessor (&Dcep::sink_node),
                       MakeBooleanChecker ())
        .AddAttribute ("SinkAddress",
                       "The destination Address of the outbound packets",
                       Ipv4AddressValue (),
                       MakeIpv4AddressAccessor (&Dcep::m_sinkAddress),
                       MakeIpv4AddressChecker ())
        .AddAttribute ("event_code",
                       "The descriptor for the type of event generated by a datasource",
                       UintegerValue (0),
                       MakeUintegerAccessor (&Dcep::event_code),
                       MakeUintegerChecker<uint16_t> ())
        .AddAttribute ("number_of_events", "The number_of_events to be generated by a datasource",
                       UintegerValue (100),
                       MakeUintegerAccessor (&Dcep::events_load),
                       MakeUintegerChecker<uint32_t> ())
        .AddAttribute ("event_interval", "The interval in between each event that is generated by a datasource",
                       UintegerValue (100),
                       MakeUintegerAccessor (&Dcep::event_interval),
                       MakeUintegerChecker<uint32_t> ())
        .AddAttribute ("routing_protocol", "The routing_protocol being used",
                       StringValue("olsr"),
                       MakeStringAccessor (&Dcep::routing_protocol),
                       MakeStringChecker())
        .AddTraceSource ("RxFinalCepEvent",
                         "a new final event has been detected.",
                         MakeTraceSourceAccessor (&Dcep::RxFinalCepEvent))
        .AddTraceSource ("RxFinalCepEventHops",
                         "",
                         MakeTraceSourceAccessor (&Dcep::RxFinalCepEventHops))
        .AddTraceSource ("RxFinalCepEventDelay",
                         "",
                         MakeTraceSourceAccessor (&Dcep::RxFinalCepEventDelay))
        
        ;
        
        return tid;
    }
    
     
    Dcep::Dcep()
    {
        this->m_cepPort = 100;
    }
    
    uint16_t
    Dcep::getCepEventCode()
    {
        return this->event_code;
    }
    
    void
    Dcep::StartApplication (void)
    {
        
        
        NS_LOG_FUNCTION (this);
        
        
        
        Ptr<UniformRandomVariable> x = CreateObject<UniformRandomVariable> ();
        uint32_t mrand = x->GetInteger (1,30);
        mrand = mrand;
        std::cout << "generated number: " << mrand << std::endl;

        Ptr<Sink> sink = CreateObject<Sink>();
        Ptr<DataSource> datasource = CreateObject<DataSource>();

        AggregateObject (sink);
        AggregateObject (datasource);
        
        Ptr<Placement> c_placement = CreateObject<Placement> ();
        
        AggregateObject (c_placement);
       
        Ptr<CEPEngine> c_cepengine = CreateObject<CEPEngine> ();
        AggregateObject (c_cepengine);
        
        Ptr<Communication> c_communication = CreateObject<Communication> ();
        AggregateObject (c_communication);
        
        c_placement->configure();
        c_cepengine->Configure();
        datasource->Configure();
        
        c_communication->setNode(GetNode());
        c_communication->setPort(m_cepPort);
        c_communication->SetAttribute("SinkAddress", Ipv4AddressValue (m_sinkAddress));
        c_communication->Configure();
        
        NS_LOG_INFO("STARTED DCEP APPLICATION AT NODE " << c_communication->GetLocalAddress());
        
        if(sink_node)
        {
            Simulator::Schedule (Seconds (20.0), &Sink::BuildAndSendQuery, sink);
        }
          
    }
    
    uint32_t
    Dcep::getNumCepEvents()
    {
        return this->events_load;
    }
    
    bool
    Dcep::isGenerator()
    {
        return this->datasource_node;
    }
    
    void
    Dcep::StopApplication (void)
    {
        NS_LOG_FUNCTION (this);
    }
    
    void
    Dcep::SendPacket(Ptr<Packet> p, Ipv4Address addr)
    {
        Ptr<Communication> comm = GetObject<Communication>();
        NS_LOG_INFO ("DCEP: Sending packet from " << comm->GetLocalAddress() << " to destination " << addr);
        comm->ScheduleSend(p, addr);
    }
    
    void
    Dcep::DispatchQuery(Ptr<Query> q)
    {
        NS_LOG_FUNCTION(this);
        NS_LOG_INFO("DCEP: received query to dispatch");

        GetObject<Placement>()->RecvQuery(q);
    }
    
    void
    Dcep::DispatchAtomicCepEvent(Ptr<CepEvent> e)
    {
        NS_LOG_INFO ("DCEP: Dispatching atomic event");
        GetObject<Placement>()->ForwardProducedCepEvent(e);
    }
    
    void
    Dcep::ActivateDatasource(Ptr<Query> q)
    {
        auto ds = GetObject<DataSource> ();
        //Simulator::Schedule(Seconds(10), &DataSource::GenerateAtomicCepEvents, GetObject<DataSource>());
        if (!ds->IsActive()) {
            ds->Activate();;
            ds->GenerateAtomicCepEvents(q->eventType);
        }
    }
    
    void 
    Dcep::SendFinalCepEventToSink(Ptr<CepEvent> event)
    {
        this->RxFinalCepEvent(1);
        this->RxFinalCepEventDelay(event->delay);
        this->RxFinalCepEventHops(event->hopsCount);

        GetObject<Sink>()->receiveFinalCepEvent(event);
    }

    void
    Dcep::DoCheckConstraints(Ptr<CepEvent> e, std::map<std::string, Ptr<Constraint>> constraints, Ptr<CEPEngine> cep, Ptr<Producer> producer, std::map<std::string, int> values)
    {
        Ptr<Placement> p = GetObject<Placement>();
        Ptr<ExecEnv> ee = GetNode()->GetObject<ExecEnv>();
        if (values.begin() == values.end()) {
            e->pkt->m_executionInfo.executedByExecEnv = false;
            ee->Proceed(e->pkt, "handle-cepops", &Placement::RcvCepEvent, p, e);
            e->pkt->m_executionInfo.curThread->m_currentLocation->getLocalStateVariable("constraints-done")->value = 1;
            return;
        }
        auto k = values.begin()->first;
        values.erase(values.begin());

        // We assume the constraints type is always integers
        e->pkt->m_executionInfo.curThread->m_currentLocation->getLocalStateVariable("constraints-type")->value = 0;

        e->pkt->m_executionInfo.curThread->m_currentLocation->getLocalStateVariable("constraints-done")->value = 0;

        if (constraints[k])
            e->pkt->m_executionInfo.curThread->m_currentLocation->getLocalStateVariable("constraint-processed")->value = 1;
        else
            e->pkt->m_executionInfo.curThread->m_currentLocation->getLocalStateVariable("constraint-processed")->value = 0;
        e->pkt->m_executionInfo.executedByExecEnv = false;
        ee->Proceed(e->pkt, "check-constraints", &Dcep::DoCheckConstraints, this, e, constraints, cep, producer, values);
    }

    void
    Dcep::CheckConstraints(Ptr<CepEvent> e)
    {
        auto cep = GetObject<CEPEngine>();

        std::vector<Ptr<CepOperator>> ops;
        cep->GetOpsByInputCepEventType(e->type, ops);
        std::map<std::string, Ptr<Constraint> > constraints;
        for (auto cepop : ops)
        {
            for (auto c : cepop->constraints)
            {
                constraints[c->var_name] = c;
            }
        }
        Ptr<Producer> producer = GetObject<Producer>();

        auto node = GetObject<Dcep>()->GetNode();
        auto ee = node->GetObject<ExecEnv>();

        //e->pkt->m_executionInfo.curThread->m_currentLocation->getLocalStateVariable("CepOpDoneYet")->value = 0;
        std::map<std::string, int> values;
        for (auto const& x : e->values)
        {
            values[x.first] = x.second;
        }
        DoCheckConstraints(e, constraints, cep, producer, values);
    }
    
    void
    Dcep::rcvRemoteMsg(uint8_t* data, uint32_t size, uint16_t msg_type, uint64_t delay)
    {

        Ptr<Placement> p = GetObject<Placement>();

        switch(msg_type)
        {
            case EVENT: /*handle event*/
            {
                Ptr<CepEvent> event = CreateObject<CepEvent>();

                event->deserialize(data, size);
                /* setting link delay from source to this node*/
                event->delay = delay;

                static int cnt = 0;
                NS_LOG_INFO ("DCEP: RECEIVED EVENT MESSAGE OF TYPE " << event->type << ", SEQ NO " << event->m_seq << ", RCVD EVENT NUMBER " << ++cnt);

                Ptr<Packet> pkt = Create<Packet>(data, size);
                event->pkt = pkt;
                Ptr<ExecEnv> ee = GetNode()->GetObject<ExecEnv>();

                pkt->m_executionInfo.executedByExecEnv = false;
                pkt->m_executionInfo.timestamps.push_back(Simulator::Now());
                ee->Proceed(event->pkt, "check-constraints", &Dcep::CheckConstraints, this, event);

                ee->ScheduleInterrupt (event->pkt, "HIRQ-1", Seconds(0));

                break;
            }

            case QUERY: /* handle query*/
            {
                NS_LOG_INFO ("DCEP: RECEIVED QUERY MESSAGE");
                Ptr<Query> q = CreateObject<Query>();
                q->deserialize(data, size);
                p->RecvQuery(q);
                // Since the send-packet SEM is invoked for each packet to be sent, query or event, maybe we should
                // invoke a HIRQ here as well, but with different state condition variable. (packet type EVENT or QUERY)
                break;
            }
                
            default:
                NS_LOG_INFO("dcep: unrecognized remote message");
                
        }
    }
    
    
    /*
     * #######################################################################
     * ####################### SINK ##########################################
     */
    
    TypeId
    Sink::GetTypeId (void)
    {
      static TypeId tid = TypeId ("ns3::Sink")
        .SetParent<Object> ()
        .AddConstructor<Sink> ()
        .AddTraceSource("new-query",
              "A newly generated query",
              MakeTraceSourceAccessor (&Sink::nquery)
              )

      ;
      return tid;
    }

    Sink::Sink ()
    {
      NS_LOG_FUNCTION (this);
    }

    Sink::~Sink ()
    {
      NS_LOG_FUNCTION (this);
    }

    void
    Sink::receiveFinalCepEvent(Ptr<CepEvent> e)
    {
        NS_LOG_INFO(Simulator::Now() << " COMPLEX EVENT RECEIVED " << ++number_received << " EVENTS, NOTIFIED HOPSCOUNT " << e->hopsCount << " DELAY " << e->delay << " TYPE " << e->type);
        NS_LOG_INFO(Simulator::Now() << "$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ COMPLEX EVENT $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ ");
    }

    void
    Sink::BuildTRexQueries(Ptr<Dcep> dcep)
    {
        std::list<std::string> eventTypes {"BC", "DE", "FG", "HI", "JK", "LM", "NO", "PQ", "RS", "TU"};
        int complex_event_cnt = 0;
        uint32_t query_counter = 1;
        double in_seconds = 0;
        for (auto eventType : eventTypes)
        {
            auto event1 = eventType.substr(0, 1);
            auto event2 = eventType.substr(1, 1);
            auto parent_output = event1 + "then" + event2;
            for (int temp = 1; temp <= 100; temp++)
            {
                Ptr<Query> q1 = CreateObject<Query> ();
                q1->actionType = NOTIFICATION;
                q1->id = query_counter++;
                q1->isFinal = false;
                q1->isAtomic = true;
                q1->eventType = event1;
                q1->output_dest = Ipv4Address::GetAny();
                q1->inevent1 = event1;
                q1->inevent2 = "";
                /*Ptr<Constraint> c = CreateObject<Constraint> ();
                c->var_name = "value";
                c->var_value = temp;
                q1->constraints.push_back(c);*/
                q1->op = "true";
                q1->assigned = false;
                q1->currentHost.Set("0.0.0.0");
                q1->parent_output = parent_output;
                Simulator::Schedule(Seconds(in_seconds), &Dcep::DispatchQuery, dcep, q1);
                //in_seconds += 0.01;
                //dcep->DispatchQuery(q1);

                Ptr<Query> q2 = CreateObject<Query> ();
                q2->actionType = NOTIFICATION;
                q2->id = query_counter++;
                q2->isFinal = false;
                q2->isAtomic = true;
                q2->eventType = event2;
                q2->output_dest = Ipv4Address::GetAny();
                q2->inevent1 = event2;
                q2->inevent2 = "";
                q2->op = "true";
                q2->assigned = false;
                q2->currentHost.Set("0.0.0.0");
                q2->parent_output = parent_output;
                Simulator::Schedule(Seconds(in_seconds), &Dcep::DispatchQuery, dcep, q2);
                //in_seconds += 0.01;
                //dcep->DispatchQuery(q2);

                Ptr<Query> q3 = CreateObject<Query> ();  // q3 = complex event
                q3->actionType = NOTIFICATION;
                q3->id = query_counter++;
                q3->isFinal = true;
                q3->isAtomic = false;
                q3->eventType = std::to_string(complex_event_cnt++);
                q3->output_dest = Ipv4Address::GetAny();
                q3->inevent1 = event1;
                q3->inevent2 = event2;
                Ptr<Constraint> c = CreateObject<Constraint> ();
                c->var_name = "value";
                c->var_value = temp % 10;
                q3->constraints.push_back(c);
                /*c = CreateObject<Constraint> ();
                c->var_name = "percentage";
                c->var_value = temp % 10;
                q3->constraints.push_back(c);*/
                q3->op = "then";
                q3->assigned = false;
                q3->currentHost.Set("0.0.0.0");
                q3->parent_output = parent_output;
                Simulator::Schedule(Seconds(in_seconds), &Dcep::DispatchQuery, dcep, q3);
                //in_seconds += 0.01;
                //dcep->DispatchQuery(q3);
            }
        }
    }

    void
    Sink::BuildAndSendQuery(){

       uint32_t query_counter = 1;

        /**
         * create and configure the query
         * 
         */
        Ptr<Dcep> dcep = GetObject<Dcep> ();
        BuildTRexQueries(dcep);
        /*
        Ptr<Query> q1 = CreateObject<Query> ();
       
        q1->actionType = NOTIFICATION;

        q1->id = query_counter++;

        q1->isFinal = false;
        q1->isAtomic = true;
        q1->eventType = "B";
        q1->output_dest = Ipv4Address::GetAny();
        q1->inevent1 = "B";
        q1->inevent2 = "";
        q1->op = "true";
        q1->assigned = false;
        q1->currentHost.Set("0.0.0.0");
        q1->parent_output = "BorC";
        NS_LOG_INFO ("Setup query " << q1->eventType);
        dcep->DispatchQuery(q1);

        Ptr<Query> q2 = CreateObject<Query> ();
        q2->actionType = NOTIFICATION;

        q2->id = query_counter++;

        q2->isFinal = false;
        q2->isAtomic = true;
        q2->eventType = "C";
        q2->output_dest = Ipv4Address::GetAny();
        q2->inevent1 = "C";
        q2->inevent2 = "";
        q2->op = "true";
        q2->assigned = false;
        q2->currentHost.Set("0.0.0.0");
        q2->parent_output = "BorC";
        NS_LOG_INFO ("Setup query " << q2->eventType);
        dcep->DispatchQuery(q2);

        Ptr<Query> q3 = CreateObject<Query> ();
        q3->actionType = NOTIFICATION;

        q3->id = query_counter++;

        q3->isFinal = true;
        q3->isAtomic = false;
        q3->eventType = "C";  // Used to be "AthenB", but that is unnecessary
        q3->output_dest = Ipv4Address::GetAny();
        q3->inevent1 = "A";
        q3->inevent2 = "B";
        q3->op = "then";
        q3->assigned = false;
        q3->currentHost.Set("0.0.0.0");
        q3->parent_output = "AthenB";
        NS_LOG_INFO ("Setup query " << q3->eventType);
        //dcep->DispatchQuery(q3);

        Ptr<Query> q4 = CreateObject<Query> ();
        q4->actionType = NOTIFICATION;

        q4->id = query_counter++;

        q4->isFinal = true;
        q4->isAtomic = false;
        q4->eventType = "D";
        q4->output_dest = Ipv4Address::GetAny();
        q4->inevent1 = "A";
        q4->inevent2 = "B";
        q4->op = "and";
        q4->assigned = false;
        q4->currentHost.Set("0.0.0.0");
        q4->parent_output = "AandB";
        NS_LOG_INFO ("Setup query " << q4->eventType);
        //dcep->DispatchQuery(q4);

        Ptr<Query> q5 = CreateObject<Query> ();
        q5->actionType = NOTIFICATION;

        q5->id = query_counter++;

        q5->isFinal = true;
        q5->isAtomic = false;
        q5->eventType = "E";
        q5->output_dest = Ipv4Address::GetAny();
        q5->inevent1 = "A";
        q5->inevent2 = "B";
        q5->op = "or";
        q5->assigned = false;
        q5->currentHost.Set("0.0.0.0");
        q5->parent_output = "AorB";
        NS_LOG_INFO ("Setup query " << q5->eventType);
        dcep->DispatchQuery(q5);*/
        

    }
    
    
    
    /*
     * ########################################################
     * ####################### DATASOURCE #########################
     */
    
    
    
    TypeId
    DataSource::GetTypeId (void)
    {
      static TypeId tid = TypeId ("ns3::Datasource")
        .SetParent<Object> ()
        .AddConstructor<DataSource> ()
        .AddTraceSource ("CepEvent",
                       "New CEP event from data source.",
                       MakeTraceSourceAccessor (&DataSource::nevent))
      
      ;
      return tid;
    }

    DataSource::DataSource ()
    : counter(0) 
    {
      NS_LOG_FUNCTION (this);
      
    }
    
    void
    DataSource::Configure()
    {
      Ptr<Dcep> dcep = GetObject<Dcep>();
      UintegerValue ecode, nevents, interval;
      
      dcep->GetAttribute("event_code", ecode);
      dcep->GetAttribute("number_of_events", nevents);
      dcep->GetAttribute("event_interval", interval);
      eventCode = ecode.Get();
      numCepEvents = nevents.Get();
      cepEventsInterval = interval.Get();
    }

    DataSource::~DataSource ()
    {
      NS_LOG_FUNCTION (this);
    }

    bool DataSource::IsActive()
    {
        return active;
    }

    void DataSource::Activate()
    {
        active = true;
    }

    void
    DataSource::GenerateAtomicCepEvents(std::string eventType){
        
        Ptr<Dcep> dcep = GetObject<Dcep>();
        Ptr<Node> node = dcep->GetNode();

        Ptr<UniformRandomVariable> x = CreateObject<UniformRandomVariable> ();

        NS_LOG_INFO ("Starting to generate events of type " << eventCode );

        do {
            m_eventValues.clear();
            uint32_t random_number = x->GetInteger (1,99999);
            eventCode = (random_number%20)+2;  // Want to select Temperature and Humidity
            //eventCode = (random_number%10)*2+2;  // We only want to select Temperature
            random_number = x->GetInteger (1,99999);
            switch (eventCode) {
                case 1:  // Fire
                    m_eventType = "A";
                    break;
                case 2:  // Temperature
                    m_eventType = "B";
                    m_eventValues["value"] = random_number % 10;
                    break;
                case 3:  // Humidity
                    m_eventType = "C";
                    m_eventValues["percentage"] = 25;
                    break;
                case 4:  // Temperature
                    m_eventType = "D";
                    m_eventValues["value"] = random_number % 10;
                    break;
                case 5:  // Humidity
                    m_eventType = "E";
                    m_eventValues["percentage"] = 25;
                    break;
                case 6:  // Temperature
                    m_eventType = "F";
                    m_eventValues["value"] = random_number % 10;
                    break;
                case 7:  // Humidity
                    m_eventType = "G";
                    m_eventValues["percentage"] = 25;
                    break;
                case 8:  // Temperature
                    m_eventType = "H";
                    m_eventValues["value"] = random_number % 10;
                    break;
                case 9:  // Humidity
                    m_eventType = "I";
                    m_eventValues["percentage"] = 25;
                    break;
                case 10:  // Temperature
                    m_eventType = "J";
                    m_eventValues["value"] = random_number % 10;
                    break;
                case 11:  // Humidity
                    m_eventType = "K";
                    m_eventValues["percentage"] = 25;
                    break;
                case 12:  // Temperature
                    m_eventType = "L";
                    m_eventValues["value"] = random_number % 10;
                    break;
                case 13:  // Humidity
                    m_eventType = "M";
                    m_eventValues["percentage"] = 25;
                    break;
                case 14:  // Temperature
                    m_eventType = "N";
                    m_eventValues["value"] = random_number % 10;
                    break;
                case 15:  // Humidity
                    m_eventType = "O";
                    m_eventValues["percentage"] = 25;
                    break;
                case 16:  // Temperature
                    m_eventType = "P";
                    m_eventValues["value"] = random_number % 10;
                    break;
                case 17:  // Humidity
                    m_eventType = "Q";
                    m_eventValues["percentage"] = 25;
                    break;
                case 18:  // Temperature
                    m_eventType = "R";
                    m_eventValues["value"] = random_number % 10;
                    break;
                case 19:  // Humidity
                    m_eventType = "S";
                    m_eventValues["percentage"] = 25;
                    break;
                case 20:  // Temperature
                    m_eventType = "T";
                    m_eventValues["value"] = random_number % 10;
                    break;
                case 21:  // Humidity
                    m_eventType = "U";
                    m_eventValues["percentage"] = 25;
                    break;
                default:
                    m_eventType = " ";

            }
        } while (dcep->GetObject<DcepState>()->lookUpCepEventRoutingTable(m_eventType)->source_query == nullptr);

        if(m_eventType != " ")
        {
            counter++;
            Ptr<CepEvent> e = CreateObject<CepEvent>();
            NS_LOG_INFO("creating event of type " << m_eventType << " cnt " << counter);
            e->type = m_eventType;
            e->event_class = ATOMIC_EVENT;
            e->delay = 0; //initializing delay
            e->m_seq = counter;
            e->hopsCount = 0;
            e->prevHopsCount = 0;
            e->values = m_eventValues;
            NS_LOG_INFO("CepEvent number  " << e->m_seq);
            dcep->DispatchAtomicCepEvent(e);

            if(counter < numCepEvents)
            {
                Simulator::Schedule (NanoSeconds (cepEventsInterval), &DataSource::GenerateAtomicCepEvents, this, m_eventType);
            }


        }
            
    }
    
}
